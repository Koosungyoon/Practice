정렬 알고리즘
============
    데이터를 특정한 기준에 따라서 순서대로 나열 하는 것이다.
    정렬 관련 알고리즘을 공부하다 보면 자연스럽게 알고리즘의 효율의 중요성을 알게된다. 
1)선택 정렬
------------
    데이터가 무작위로 나열 되어있을때 이중에서 가장 작은 데이터를 선택해 맨 앞에 잇는 데이터와 바꾸고,
    그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다.
    !!매번 가장 작은 것을 선택한다.!!
    
    선택 정렬의 시간 복잡도
        n-1번 만큼 가장 작은 수를 찾아서 맨앞으로 보내야함. 또한 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요함.
        이중 포문이 있어서 빅오 표기법으로 표현하면 O(N**2)이다.
    
2)삽입 정렬
-----------
    데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입한다.
    삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
    신기한 특징이 하나 발생한다.
        정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 것!!
        이러한 특징 때문에 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정할 떄 삽입될 데이터보다 작은 데이터를 만나면 
        그 위치에서 멈추면 된다.
    
    삽입 정렬의 시간 복잡도
        선택정렬과 마찬가지로 반복문이 2번 중첩되어 O(N**2)으로 표현된다.
        보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 강력하다.

3)퀵 정렬
---------
    가장 많이 사용되는 알고리즘이다.
    기준 데이터를 설정하고, 그 기준보다 큰 데이터를 작은 데이터의 위치를 바꾼다.
    기준 데이터는 피벗(pivot)이다. 피벗을 어떻게 설정 할 것인지 미리 명시해야 하는데, 리스트를 분할하는 방법에 따라서 방식이
    달라진다. 예시로 호어 분할에 대해서 알아보자.
    1.리스트에서 첫 번째 데이터를 피벗으로 정한다.
    (1)파트
        피벗을 기준으로 좌측은 피벗보다 작은 수, 우측은 피벗보다 큰수로 정렬 되게끔 분할(파티션)한다.
    (2)파트,(3)파트
        각각의 파트에서 피벗을 통해서 분할한다. 
        리스트의 원소 데이터개수가 1개인 경우에 종요한다.(재귀함수를 이용하므로 종료조건이 필요!!!!!!!!!)
    