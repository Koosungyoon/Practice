정렬 알고리즘
============
    데이터를 특정한 기준에 따라서 순서대로 나열 하는 것이다.
    정렬 관련 알고리즘을 공부하다 보면 자연스럽게 알고리즘의 효율의 중요성을 알게된다. 
1)선택 정렬
------------
    데이터가 무작위로 나열 되어있을때 이중에서 가장 작은 데이터를 선택해 맨 앞에 잇는 데이터와 바꾸고,
    그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다.
    !!매번 가장 작은 것을 선택한다.!!
    
    선택 정렬의 시간 복잡도
        n-1번 만큼 가장 작은 수를 찾아서 맨앞으로 보내야함. 또한 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요함.
        이중 포문이 있어서 빅오 표기법으로 표현하면 O(N**2)이다.
    
2)삽입 정렬
-----------
    데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입한다.
    삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
    신기한 특징이 하나 발생한다.
        정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 것!!
        이러한 특징 때문에 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정할 떄 삽입될 데이터보다 작은 데이터를 만나면 
        그 위치에서 멈추면 된다.
    
    삽입 정렬의 시간 복잡도
        선택정렬과 마찬가지로 반복문이 2번 중첩되어 O(N**2)으로 표현된다.
        보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 강력하다.

3)퀵 정렬
---------
    가장 많이 사용되는 알고리즘이다.
    기준 데이터를 설정하고, 그 기준보다 큰 데이터를 작은 데이터의 위치를 바꾼다.
    기준 데이터는 피벗(pivot)이다. 피벗을 어떻게 설정 할 것인지 미리 명시해야 하는데, 리스트를 분할하는 방법에 따라서 방식이
    달라진다. 예시로 호어 분할에 대해서 알아보자.
    1.리스트에서 첫 번째 데이터를 피벗으로 정한다.
    (1)파트
        피벗을 기준으로 좌측은 피벗보다 작은 수, 우측은 피벗보다 큰수로 정렬 되게끔 분할(파티션)한다.
    (2)파트,(3)파트
        각각의 파트에서 피벗을 통해서 분할한다. 
        리스트의 원소 데이터개수가 1개인 경우에 종요한다.(재귀함수를 이용하므로 종료조건이 필요!!!!!!!!!)

    다만, 퀵 정렬의 시간 복잡도에 대하여 한 가지 기억해둘 점이 있다. 바로 평균적으로 시간 복잡도가 O(N로그N)이지만 최악의 경우 시간 복잡도가O(n**2)
    이라는 것이다. 데이터가 무작위로 입력되는 경우 퀵 정렬은 빠르게 동작할 확률이 높다. 하지만 리스트의 가장 왼쪽 데이터를 피벗으로 삼을 때, '이미 데이터가 정렬되어 있는 경우'에는 매우 느리게 동작한다.
    위의 삽입 정렬은 이미 데이터가 정렬되어 있는 경우에는 매우 빠르게 동작한다고 했는데, 퀵 정렬은 그와 반대된다고 이해하면 된다.

4)계수 정렬
-----------
    특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
    계수 정렬은 최악의 경우에도 수행시간O(N+K)를 보장한다. 그러나 '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을떄'만 사용 가능!
    가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다. 왜냐하면
    모든 범위를 담을 수 이ㅛ는 크기의 리스트를 선언해야하기 떄문이다.
    계수 정렬은 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식(비교 기반의 정렬 알고리즘)이 아니다.

    1) 가장 큰 데이터 가장 작은 데이터 범위가 모두 담길 수 있는 하나의 리스트를 생성
    2) 리스트에 몇번 등장 했는지 그 횟수를 기록
    3) 리스트의 첫 번째 데이터 부터 하나씩 그 값만큼 인덱스를 출력

    계수 정렬의 시간 복잡도와 공간 복잡도
        시간 복잡도는 O(N+K)이다. 데이터의 개수 N개를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 
        추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야하므로 시간 복잡도는 위와 같다.
        데이터 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다.
        기수 정렬과 더불어 빠른 알고리즘이다.
        그러면 기수 정렬은 무엇인가 (가볍게)?
            기수 정렬은 계수 정렬에 비해서 동작은 느리지만 처리가능한 정수의 크기는 더 크다. 그러나 소스코드는 복잡하다.
        계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다.

5)파이썬의 정렬 라이브러리
------------------------
    sorted(),sort()함수
        동작 방식이 병합 정렬을 기반으로 만들어 졌는데 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도는 O(NlogN)을 보장함
        sorted()함수는 리스트,딕셔너리 자료형 등을 입력받아서 정렬된 결과(반드시 리스트 자료형)

    
결론
====
    1.정렬 라이브러리로 풀 수 있는 문제: 단순히 정렬 기범을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하면 됨
-----------------------------------------------------------------------------------------------------------------------------
    2.정렬 알고리즘의 원리에 대해서 물어보는 문제: 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리르 알고 있어야 함
-----------------------------------------------------------------------------------------------------------------------------
    3.더 빠른 정렬이 필요한 문제: 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 
------------------------------------------------------------------------------------------------------------------------------------------
    알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.
----------------------------------------------
