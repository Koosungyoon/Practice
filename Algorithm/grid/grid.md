그리디 알고리즘(탐욕법)
======================
현재 상황에서 지금 당장 좋은 것만 고르는 방법 이라 한다!
    매 순간 가장 좋아 보이는 것을 선택하고 현재의 선택이 추후에 영향을 줄지는 신경쓰지 않는다.
예시로는 거스름돈 문제가 있다.
    손님에게 거스름돈n을 나누어 주는데 동전의 개수를 가능한한 적게 내주는 방법이다
    (단, 동전의 개수는 무제한이고 n은 10의 배수이다.)
    ->가장 큰 화폐 단위부터 돈을 거슬러 주면 되는 것이다!
    코드로 구현해보면 다음과 같다.
    
    n=1260 #거스름돈이 1260 이라 하자
    count=0

    coin_types=[500,100,50,10]
    for coin in coin_types:
        count+=n//coin
        n%=coin
    print(count)
    
    결론부터 보면 영향을 받는 것은 n의 크기가아니라 coin_types이다. 시간복잡도로 보면 O(코인의 종류수)이다.

그리디 알고리즘으로 문제의 해법을 찾았다면 그 해법이 정당한지 검토해야한다.
거스름돈 문제를 그리디 알고리즘으로 해결 할 수 있었던 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 
작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.
대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정단한지 검토 할 수 있어야 답을 
도출 할 수 있음!

문제-> 그리디 알고리즘으로 풀 수 있나?
    아니라면 -> 다이나믹 프로그래밍 or 그래프 알고리즘으로 풀 수 잇는지 고민 해보는것!

그리디 알고리즘은 부분의 최적해들의 집합이 곧 전체 문제의 해답이 될 떄
사용 할 수 있을 듯하다