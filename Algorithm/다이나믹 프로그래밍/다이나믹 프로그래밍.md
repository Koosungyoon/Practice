다이나믹 프로그래밍('프로그램이 실행되는 도중에')
==============================================
(중복되는 연산을 줄인다.)
------------------------
    다이나믹 프로그래밍, 메모제이션 기법, 탑다운(재귀함수),보텀업(반복문)

    예시로 피보나치 수열을 이용하여 설명할 것이다.
    피보나치 수열
        -n번째 피보나치수 = (n-1)번쨰 피보나치 수 + (n-2)번쨰 피보나치 수
        -단, 1번째 피보나치수,2번째 피보나치수 모두 1
    
    아무것도 고려 하지 않은 피보나치 함수 소스 코드
    '''
        def fibo(x):
            if x==1 or x==2:
                return 1
            return fibo(x-1)+fibo(x-2)
    '''
    ->>> f(n)함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다. 
         시간 복잡도를 확인해보면 O(2**N)의 지수 시간이 소요된다.  
         이러한 이유는 동일한 함수가 반복적으로 호출 되기때문이다. 문제 효율이 떨어진다.
        
    따라서 다이나믹 프로그래밍을 사용하여 문제를 해결하자.
        1.큰 문제를 작은 문제로 나눌 수 있다.
        2.작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

        메모제이션 기법을 = 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
    
    피보나치 수열 소스코드(재귀적)-탑다운(큰 문제를 해결하기 위해 작은 문제를 호출)
    '''
    #한 번 계산된 결과를 메모제이션(memozation)하기 위한 리스트 초기화
    d=[0]*100
    #피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
    def fibo(x):
        #종료조건
        if x==1 or x==2:
            return 1
        #이미 계산된 결과하면 그대로 반환
        if d[x]!=0:
            return d[x]
        #아직 계산되지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x]=fibo(x-1)+fibo(x-2)
        return d[x]
    '''
    
    정리해보면,다이나믹 프로그래밍은 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘이다.
        참고로,큰 문제를 작게 나누는 것이 퀵 정렬과 비슷하다. 퀵 정렬은 (분할 정복),Divide and Conquer 알고리즘으로 분류된다.
        하지만,다이나믹 프로그래밍과 분할 정복의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.

    재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 떄 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다.-> 반복문을 사용하여 오버 헤드를 줄일 수 있다.

    피보나치 수열 소스코드(반복적)-바텀업(반복문을 이용하여 작은 문제부터 차근차근 답을 도출한다.)
    '''
    #앞서 계산된 결과를 저장하기위한 DP 테이블 초기화
    d=[0]*100

    #첫 번째 피보나치 수와 두 번째 피보나치 수는 1
    d[1]=1
    d[2]=1
    n=99
    
    #피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
    for i in range(3,n+1):
        d[i]=d[i-1]+d[i-2]

    print(d[n])
    '''
    다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다. 보텀업 방식에서 사용되는 결과 저장용리스트는'DP 테이블'
    이라고 부른다.
    
    메모제이션은 때에 따라서 다른 자료형,(dict)딕셔너리 자료구조형을 사용하기도 한다. 연속적이지 않은 경우에 유용

    가능하다면 보텀업 방식으로 구현하자. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.
    만약, 재귀 함수를 이용하여 문제를 해결하고자할 때 'recursion Depth'관련된 오류가 발생할 수 있다. 
    -> sys 라이브러리에 포함되어 있는 setreculsionlimit()함수를 호출하여 재귀 제한을 완화할 수 있다.
